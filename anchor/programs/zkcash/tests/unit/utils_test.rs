use ark_bn254;
use ark_ff::{PrimeField};
use ark_serialize::{CanonicalSerialize};
use zkcash::{groth16::{Groth16Verifyingkey}, utils::{check_public_amount}};
use ark_bn254::Fr;

pub const VERIFYING_KEY: Groth16Verifyingkey =  Groth16Verifyingkey {
	nr_pubinputs: 8,

	vk_alpha_g1: [
		45,77,154,167,227,2,217,223,65,116,157,85,7,148,157,5,219,234,51,251,177,108,100,59,34,245,153,162,190,109,242,226,
		20,190,221,80,60,55,206,176,97,216,236,96,32,159,227,69,206,137,131,10,25,35,3,1,240,118,202,255,0,77,25,38,
	],

	vk_beta_g2: [
		9,103,3,47,203,247,118,209,175,201,133,248,136,119,241,130,211,132,128,166,83,242,222,202,169,121,76,188,59,243,6,12,
		14,24,120,71,173,76,121,131,116,208,214,115,43,245,1,132,125,214,139,192,224,113,36,30,2,19,188,127,193,61,183,171,
		48,76,251,209,224,138,112,74,153,245,232,71,217,63,140,60,170,253,222,196,107,122,13,55,157,166,154,77,17,35,70,167,
		23,57,193,177,164,87,168,199,49,49,35,210,77,47,145,146,248,150,183,198,62,234,5,169,213,127,6,84,122,208,206,200,
	],

	vk_gamme_g2: [
		25,142,147,147,146,13,72,58,114,96,191,183,49,251,93,37,241,170,73,51,53,169,231,18,151,228,133,183,174,243,18,194,
		24,0,222,239,18,31,30,118,66,106,0,102,94,92,68,121,103,67,34,212,247,94,218,221,70,222,189,92,217,146,246,237,
		9,6,137,208,88,95,240,117,236,158,153,173,105,12,51,149,188,75,49,51,112,179,142,243,85,172,218,220,209,34,151,91,
		18,200,94,165,219,140,109,235,74,171,113,128,141,203,64,143,227,209,231,105,12,67,211,123,76,230,204,1,102,250,125,170,
	],

	vk_delta_g2: [
		20,141,168,118,84,107,128,101,211,229,148,150,67,168,191,115,91,227,15,176,61,50,191,22,109,58,182,33,242,193,62,81,
		22,207,69,177,5,121,230,121,251,23,33,203,250,169,213,78,126,17,45,75,88,91,189,172,171,97,174,27,71,196,188,17,
		12,213,102,97,167,16,230,38,31,91,30,86,97,165,223,197,104,174,177,226,248,154,122,56,39,16,194,179,88,154,164,221,
		3,161,172,35,90,225,242,125,156,224,146,154,214,237,219,157,48,69,229,113,218,131,134,73,148,209,109,167,194,97,2,215,
	],

	vk_ic: &[
		[
			22,102,95,145,175,147,31,150,31,30,121,204,58,223,169,0,50,185,222,79,27,216,118,7,191,93,156,74,120,37,133,23,
			47,178,98,3,18,2,19,238,102,203,128,215,31,70,158,224,119,204,127,8,199,23,11,72,166,189,196,153,130,20,210,4,
		],
		[
			0,15,203,93,134,105,229,223,22,236,46,125,212,107,191,208,142,224,197,135,68,180,236,233,112,160,91,170,10,192,190,72,
			27,29,181,159,152,120,78,224,4,246,8,158,230,136,141,5,184,119,139,103,9,224,64,186,89,70,4,40,109,167,51,184,
		],
		[
			2,192,237,146,40,137,121,252,233,190,175,2,49,245,31,31,192,108,246,30,248,101,62,165,138,163,224,60,252,5,154,5,
			23,32,86,191,169,94,90,129,216,63,196,35,177,209,137,188,153,201,88,95,211,53,128,216,52,247,124,97,27,212,52,189,
		],
		[
			4,124,147,8,19,106,82,195,14,220,198,30,35,215,67,204,163,70,217,100,107,1,34,154,196,175,13,156,230,68,110,232,
			8,156,208,28,65,97,249,30,221,89,57,190,93,28,129,95,54,122,235,42,75,51,121,171,15,11,188,195,45,183,153,24,
		],
		[
			12,134,110,103,149,7,208,186,246,223,195,211,236,68,34,159,40,117,2,95,132,132,247,82,184,67,243,74,84,71,207,137,
			32,67,87,27,226,12,246,15,25,16,204,56,87,190,47,94,29,124,83,84,155,238,183,4,127,121,53,189,134,112,179,152,
		],
		[
			8,178,234,135,103,180,183,102,158,101,228,31,120,184,36,116,67,232,153,124,53,255,230,181,65,33,76,73,148,105,174,125,
			25,214,223,180,222,232,82,159,55,166,254,72,177,98,68,130,215,97,59,20,164,252,192,236,86,13,54,207,50,49,212,212,
		],
		[
			32,192,87,52,137,55,209,207,255,179,175,175,210,222,191,68,235,8,35,251,144,161,216,86,172,23,191,243,87,20,206,232,
			40,241,150,202,59,189,191,252,121,163,80,231,239,58,127,14,69,80,93,154,158,17,99,184,20,20,93,234,132,166,171,67,
		],
		[
			28,140,162,144,74,35,43,227,127,175,76,212,5,193,125,88,51,43,230,63,210,181,232,40,163,171,179,44,137,128,47,245,
			6,39,70,66,52,35,253,220,190,80,4,162,193,75,96,79,29,202,154,16,41,173,168,93,97,229,209,252,10,88,186,34,
		],
	]
};

pub const PROOF_A: [u8; 64] = [9, 101, 79, 49, 149, 141, 103, 58, 176, 62, 171, 221, 58, 75, 157, 225, 180, 253, 91, 203, 17, 2, 221, 241, 62, 220, 34, 58, 2, 105, 174, 167, 26, 21, 118, 59, 5, 103, 19, 40, 212, 45, 74, 139, 40, 176, 29, 73, 210, 39, 111, 129, 237, 53, 32, 255, 242, 88, 223, 90, 59, 238, 174, 32];

pub const PROOF_B: [u8; 128] = [17, 48, 97, 20, 189, 195, 107, 129, 9, 71, 155, 9, 63, 134, 23, 182, 111, 29, 231, 133, 170, 193, 126, 73, 155, 90, 151, 167, 206, 254, 21, 15, 34, 201, 58, 82, 144, 204, 85, 126, 116, 131, 84, 99, 211, 23, 9, 216, 168, 81, 170, 21, 229, 116, 6, 18, 93, 114, 166, 1, 246, 108, 198, 81, 31, 195, 10, 141, 218, 148, 251, 42, 59, 247, 115, 203, 126, 159, 68, 231, 46, 200, 104, 32, 34, 155, 185, 61, 134, 127, 163, 200, 143, 188, 205, 151, 38, 77, 113, 95, 57, 222, 13, 109, 227, 178, 181, 255, 68, 21, 15, 243, 211, 6, 79, 12, 123, 76, 5, 91, 85, 34, 223, 35, 93, 9, 68, 38];

pub const PROOF_C: [u8; 64] = [39, 155, 227, 122, 72, 230, 5, 40, 18, 48, 98, 240, 3, 48, 242, 33, 245, 157, 25, 64, 56, 212, 197, 110, 106, 219, 174, 161, 192, 155, 234, 95, 3, 207, 171, 93, 239, 89, 132, 212, 244, 234, 131, 75, 103, 27, 123, 204, 31, 222, 119, 78, 39, 41, 3, 230, 155, 55, 10, 176, 80, 216, 116, 40];

pub const PUBLIC_INPUTS: [[u8; 32]; 7] = [
  [
     35, 161,  18, 131,  56,  38, 188,  27,
    101, 227, 159,  52, 254, 160, 186, 130,
    137, 100, 171,  64,  88, 173,   6,  11,
     82, 139, 240,   1, 116, 187, 156, 235
  ],
  [
     48, 100,  78, 114, 225,  49, 160,  41,
    184,  80,  69, 182, 129, 129,  88,  93,
     40,  51, 232,  72, 121, 185, 112, 145,
     67, 225, 245, 147, 180, 101,  54,   1
  ],
  [
     48,  50,  60,  43,  99, 146, 214, 176,
     69,  73,  26, 119, 196,  11,  71,  84,
    137, 171, 216,  23, 133,  73, 210, 235,
    128, 201, 160, 201, 232,  20, 116,  88
  ],
  [
      5,  92,  25, 230,   5, 162, 134, 133,
    166, 112,  65, 155, 182,  96, 208,  46,
    205, 139, 163, 145, 197, 177,  78,  21,
    247, 241,  47,  96, 150, 194, 135,  98
  ],
  [
     26,  79,  74, 238, 109,  74,  54,  57,
    158, 229, 214,  36, 144, 160, 152, 130,
     24,  92,  24,  25,  33, 108, 162, 159,
      3, 157,  27,  18, 121, 189, 161, 250
  ],
  [
     30, 152,  34, 188,  70, 167,  30, 233,
    228, 252,  11, 230,  96,  72, 244, 193,
     85,  75, 172, 184, 156,  45, 234, 188,
     44,  23,  63, 125, 151, 248, 245, 146
  ],
  [
    20, 250, 221, 250,   2, 213, 184,  58,
     1,  97, 101,  21, 222, 165,  77,  69,
    67, 219,  13, 213, 144,  47, 118, 176,
    99,  37, 246, 197,  50, 218, 238, 179
  ]
];

// BN254 field modulus for tests
pub fn field_modulus() -> Fr {
    Fr::from_be_bytes_mod_order(&[
        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29,
        0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58, 0x5d,
        0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
    ])
}

#[cfg(test)]
mod tests {
    use super::*;

    // Helper function to convert Fr to big-endian bytes for testing
    fn fr_to_be_bytes(fr: Fr) -> [u8; 32] {
        let mut bytes = [0u8; 32];
        fr.serialize_uncompressed(&mut bytes[..]).unwrap();
        // Reverse to get big-endian format
        bytes.reverse();
        bytes
    }

    #[test]
    fn test_check_public_amount_positive_ext_amount() {
        let ext_amount: i64 = 100;
        let fee: u64 = 10;
        
        // Calculate expected: ext_amount - fee = 90
        let expected_fr = Fr::from(90u64);
        let expected_bytes = fr_to_be_bytes(expected_fr);
        
        assert!(check_public_amount(ext_amount, fee, expected_bytes));
    }

    #[test]
    fn test_check_public_amount_negative_ext_amount() {
        let ext_amount: i64 = -100;
        let fee: u64 = 10;
        
        // Calculate expected: -(|ext_amount| + fee) = -(100 + 10) = -110
        let abs_amount_fr = Fr::from(100u64);
        let fee_fr = Fr::from(10u64);
        let expected_fr = -(abs_amount_fr + fee_fr);
        
        let expected_bytes = fr_to_be_bytes(expected_fr);
        
        assert!(check_public_amount(ext_amount, fee, expected_bytes));
    }

    #[test]
    fn test_check_public_amount_ext_amount_equal_fee() {
        let ext_amount: i64 = 10;
        let fee: u64 = 10;
        let dummy_bytes = [0u8; 32];
        
        // Should return false when ext_amount <= fee for deposits
        assert!(!check_public_amount(ext_amount, fee, dummy_bytes));
    }

    #[test]
    fn test_check_public_amount_ext_amount_less_than_fee() {
        let ext_amount: i64 = 5;
        let fee: u64 = 10;
        let dummy_bytes = [0u8; 32];
        
        // Should return false when ext_amount < fee for deposits
        assert!(!check_public_amount(ext_amount, fee, dummy_bytes));
    }

    #[test]
    fn test_check_public_amount_i64_min() {
        let ext_amount: i64 = i64::MIN;
        let fee: u64 = 10;
        let dummy_bytes = [0u8; 32];
        
        // Should return false for i64::MIN
        assert!(!check_public_amount(ext_amount, fee, dummy_bytes));
    }

    #[test]
    fn test_check_public_amount_wrong_bytes() {
        let ext_amount: i64 = 100;
        let fee: u64 = 10;
        let wrong_bytes = [1u8; 32]; // Wrong bytes
        
        // Should return false for incorrect bytes
        assert!(!check_public_amount(ext_amount, fee, wrong_bytes));
    }

    #[test]
    fn test_check_public_amount_zero_ext_amount() {
        let ext_amount: i64 = 0;
        let fee: u64 = 10;
        let dummy_bytes = [0u8; 32];
        
        // Should return false when ext_amount is 0 and fee > 0
        assert!(!check_public_amount(ext_amount, fee, dummy_bytes));
    }

    #[test]
    fn test_check_public_amount_zero_fee() {
        let ext_amount: i64 = 100;
        let fee: u64 = 0;
        
        // Calculate expected: ext_amount - fee = 100 - 0 = 100
        let expected_fr = Fr::from(100u64);
        let expected_bytes = fr_to_be_bytes(expected_fr);
        
        assert!(check_public_amount(ext_amount, fee, expected_bytes));
    }

    #[test]
    fn test_field_arithmetic_consistency() {
        // Test that our field arithmetic is consistent
        let a = Fr::from(100u64);
        let b = Fr::from(50u64);
        let result = a - b;
        let expected = Fr::from(50u64);
        
        assert_eq!(result, expected);
    }

    #[test]
    fn test_negative_field_arithmetic() {
        // Test negative field arithmetic
        let a = Fr::from(100u64);
        let b = Fr::from(50u64);
        let result = -(a + b);
        
        // In field arithmetic, this should be field_modulus - 150
        let expected_value = field_modulus() - Fr::from(150u64);
        assert_eq!(result, expected_value);
    }
}